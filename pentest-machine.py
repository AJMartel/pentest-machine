#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import sys
import time
import signal
import argparse
import requests
import subprocess
from libnmap.process import NmapProcess
from subprocess import Popen, STDOUT, PIPE
from multiprocessing import Lock, Process, Queue
from libnmap.parser import NmapParser, NmapParserException

# Debug
#from IPython import embed
# Requires:
#  patator
#    ssh_brute in patator needs paramiko

def parse_args():
    # Create the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-x", "--nmapxml", help="Nmap XML file to parse")
    parser.add_argument("-l", "--hostlist", help="Host list file")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Number of parallel workers")
    return parser.parse_args()

def main(report, num_workers):
    '''
    Run through the hosts' available services appending their respective commands
    to a list, then have x number of workers run through those commands
    '''
    procs = []
    lock = Lock()
    q = Queue()

    # Catch CTRL-C
    def signal_handler(signal, frame):
        print '[-] Killing processess and closing...'
        for p in procs:
            p.terminate()
        q.close()
    signal.signal(signal.SIGINT, signal_handler)

    # Create output directories
    if not os.path.exists('output-by-host'):
        os.makedirs('output-by-host')
    if not os.path.exists('output-by-service'):
        os.makedirs('output-by-service')

    # Go through the hosts
    hostname = None
    for host in report.hosts:
        ip = host.address
        if host.is_up():
            # type(host.hostnames) == list
            if len(host.hostnames) != 0:
                hostname = host.hostnames[0]
                print '\n[*] Host: {0}  Hostname: {1}'.format(ip, hostname)
            else:
                print '\n[+] Host: {0}'.format(ip)

            # Add the various cmds and filenames to the queue
            get_services(host, hostname, ip, q)

    # Go through the queue with x number of workers
    for w in xrange(num_workers):
        p = Process(target=worker, args=(q, lock))
        p.start()
        procs.append(p)
        q.put('STOP')

    for p in procs:
        p.join()

# Lets make this write its output by host and by protocol
# one folder named output-by-host another output-by-protocol
def get_services(host, hostname, ip, q):
    '''
    For each service type, add a command to run against it to the queue
    '''
    if len(host.services) == 0:
        print '[-] No services detected'
    for s in host.services:
        #if 'open' in s.state or 'filtered' in s.state:
        port = str(s.port)
        print '[*]   {0}/{1} {2} {3} {4}'.format(port, s.protocol, s.state, s.service, s.servicefp)
        ip_port = '{0}:{1}'.format(ip, port)

        # Brute with patator?
        # DNS
        # IKE
        #  ike-scan
        # HTTP
        #  arachni?
        #  wfuzz dirbusting
        # MSSQL
        #   brute user sa since it can't be locked out
        #   blank login
        # MySQL
        #   blank login
        # Postgresql
        #   brute/blank login
        # DHCP
        #   ?
        # LDAP
        #   brute

        # HTTP
        if 'http' in s.service:
            http_cmds(q, ip_port, hostname, s.service)

        # SMTP
        elif 'smtp' in s.service:
            smtp_cmds(q, ip, ip_port)

        # UNTESTED SMB
        elif 'smb' in s.service:
            smb_cmds(q, ip, ip_port)

        # UNTESTED RPC
        elif 'rpc' in s.service:
            rpc_cmds(q, ip, ip_port)

        # UNTESTED SNMP
        elif 'snmp' in s.service:
            snmp_cmds(q, ip)

        # FTP
        elif 'ftp' in s.service:
            ftp_cmds(q, ip_port)

        # SSH
        elif 'ssh' in s.service:
            ssh_cmds(q, ip_port)

        # Telnet
        elif 'telnet' in s.service:
            telnet(q, ip_port)

def telnet(q, ip_port):
    '''
    Runs: patator telnet_login
    '''
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    # Brute force (never more than 2 tries per username to avoid lockout
    telnet = "patator telnet_login host=192.168.0.1 inputs='COMBO00\nCOMBO01' 0=userpass.list \
--max-retries -2 -x reset,ignore:egrep!='.+[Ll]ogin:'"
    q.put((telnet, ip, 'Telnet'))

def ssh_cmds(q, ip_port):
    '''
    Runs: patator ssh_login
    '''
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    # Brute force (never more than 2 tries per username to avoid lockout
    # -x free=user:code0 means stop testing the user after successful login
    ssh_login = 'patator ssh_login host={0} user=COMBO00 password=COMBO01 0=userpass.list \
-x ignore:fgrep="failed." -x free=user:code=0 port={1} --max-retries -2'.format(ip, port)
    q.put((ssh_login, ip, 'SSH'))

def ftp_cmds(q, ip_port):
    '''
    Runs: patator ftp_login, anon login
    '''
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    # Anonymous login
    ftp_anon1 = 'patator ftp_login host={0} user=anonymous password=test@example.com port={1} --max-retries -2'.format(ip, port)
    q.put((ftp_anon1, ip, 'FTP'))

    # Brute force (never more than 2 tries per username to avoid lockout
    ftp_login = 'patator ftp_login host={0} user=COMBO00 password=COMBO01 0=userpass.list \
-x ignore:egrep="failed" -x free=user:code=0 port={1} --max-retries -2'.format(ip, port)
    q.put((ftp_login, ip, 'FTP'))

def snmp_cmds(q, ip):
    '''
    Runs snmapcheck with 'public' and 'private' strings
    '''
    snmpcheck = '/usr/bin/snmpcheck -t {0}'.format(ip)
    q.put((snmpcheck, ip, 'SNMP'))
    snmpcheck1 = '/usr/bin/snmpcheck -t {0} -c "private"'.format(ip)
    q.put((snmpcheck1, ip, 'SNMP'))

def rpc_cmds(q, ip, ip_port):
    port = ip_port.split(':')[1]
    nmap_nfs = '/usr/bin/nmap -n -Pn -pT:{0} -sV --script nfs-showmount {1}'.format(port, ip)
    q.put((nmap_nfs, ip, 'RPC'))

def http_cmds(q, ip_port, hostname, service):
    '''
    Form all the commands to run against HTTP services
    and add them to the Queue
    Runs: nikto, whatweb
    '''
    # If fail == True, then couldn't make a connection on
    # HTTPS or HTTP
    ssl, fail = test_ssl(hostname, ip_port)
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    nikto = '/usr/bin/nikto -h {0}'.format(ip_port)
    q.put((nikto, ip, 'HTTP'))

    if fail == False:
        whatweb = get_whatweb_cmd(ip_port, hostname, ssl)
        q.put((whatweb, ip, 'HTTP'))

def test_ssl(hostname, ip_port):
    '''
    Test if service is accessible via SSL or not
    '''
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]
    fail = False
    ssl = False

    # HTTP
    if hostname:
        req = requests.get('http://{0}'.format(hostname))
    else:
        req = requests.get('http://{0}'.format(ip))
    if req.status_code != 200:
        fail = True

    # HTTPS
    if fail == True:
        if hostname:
            req = requests.get('https://{0}'.format(hostname))
        else:
            req = requests.get('https://{0}'.format(ip))
        if req.status_code == 200:
            fail = False
            ssl = True

    return ssl, fail

def get_whatweb_cmd(ip_port, hostname, ssl):
    '''
    Make the WhatWeb command
    '''
    port = ip_port.split(':')[1]
    if ssl == True:
        if hostname:
            hostname = 'https://{0}'.format(hostname)
            whatweb = '/usr/bin/whatweb {0}'.format(hostname)
        else:
            ip = 'https://{0}'.format(ip)
            whatweb = '/usr/bin/whatweb {0}'.format(ip)
    else:
        if hostname:
            hostname = 'http://{0}'.format(hostname)
            whatweb = '/usr/bin/whatweb {0}'.format(hostname)
        else:
            ip = 'http://{0}'.format(ip)
            whatweb = '/usr/bin/whatweb {0}'.format(ip)

    return whatweb

def smtp_cmds(q, ip, ip_port):
    '''
    Runs: Nmap NSE smtp-enum-users,smtp-open-relay
    '''
    port = ip_port.split(':')[1]
    nmap_smtp = '/usr/bin/nmap -Pn -n -p {0} --script smtp-enum-users,smtp-open-relay {1}'.format(port, ip)
    q.put((nmap_smtp, ip, 'SMTP'))

def smb_cmds(q, ip, ip_port, hostname):
    '''
    Runs: enum4linux -a
    '''
    enum4linux = '/usr/bin/enum4linux -a {0}'.format(ip)
    q.put((enum4linux, ip, 'SMB'))
    nmap_smb = '/usr/bin/nmap -Pn -n -p {0} --script smb-check-vulns,smb-enum-shares {1}'.format(port, ip)
    q.put((nmap_smb, ip, 'SMB'))

def worker(q, lock):
    '''
    Multiprocessing worker that actually runs the commands
    '''
    for cmd, ip, serv in iter(q.get, 'STOP'):
        cmd_list = cmd.split()
        print '[+] Running command: {0}'.format(' '.join(cmd_list))

        proc = Popen(cmd_list, stdout=PIPE, stderr=STDOUT)
        out = proc.communicate()[0].strip()

        # Escape colors like whatweb has
        ansi_escape = re.compile(r'\x1b[^m]*m')
        out = ansi_escape.sub('', out)

        msg = '\n[*] COMMAND: {0}\n{1}\n'.format(cmd, out)
        print msg

        with lock:
            with open('output-by-host/{0}.txt'.format(ip), 'a+') as f:
                f.write(msg+out)
            with open('output-by-service/{0}.txt'.format(serv), 'a+') as f:
                f.write(msg+out)
    print ''

def nmap_scan(hosts):
    '''
    Do Nmap scan
    '''
    # -sV is included by default in NmapProcess nmap cmd
    # To add more:  options = '-T4 -sU -p-'
    #                 hosts = ['192.168.0.1', '192.168.0.2']
    #nmap_args = '-T4 -sV -sS -pU:161,137,139'# -sS -sU --top-ports'
    nmap_args = '-T4 -sS -sV --max-rtt-timeout 150ms --max-retries 3'
    print '[+] Running: nmap {0} -iL <hostlist>'.format(nmap_args)
    nmap_proc = NmapProcess(targets=hosts, options=nmap_args)
    #rc = nmap_proc.sudo_run()
    rc = nmap_proc.sudo_run_background()
    while nmap_proc.is_running():
        print("[*] Nmap progress: {1}%".format(nmap_proc.etc,
                                                              nmap_proc.progress))
        time.sleep(2)

    xml = nmap_proc.stdout

    try:
        report = NmapParser.parse(nmap_proc.stdout)
    except NmapParserException as e:
        print 'Exception raised while parsing scan: {0}'.format(e.msg)
        sys.exit()

    return report


if __name__ == "__main__":
    args = parse_args()

    if args.nmapxml:
        report = NmapParser.parse_fromfile(args.nmapxml)
    elif args.hostlist:
        with open(args.hostlist, 'r') as hostlist:
            hosts = hostlist.read().split()
        report = nmap_scan(hosts)
    else:
        print 'Please use the "-x [nmapoutput.xml]" option if you already have an nmap XML file \
or "-l [hostlist.txt]" option to run an nmap scan with a hostlist file.'
        sys.exit()

    main(report, args.workers)
