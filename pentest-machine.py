#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import time
import argparse
import trollius
import subprocess
from functools import partial
from contextlib import closing
from trollius import From, Return
from libnmap.process import NmapProcess
from trollius.subprocess import PIPE, STDOUT
from libnmap.parser import NmapParser, NmapParserException

from IPython import embed

'''
http: nikto, httpscreenshot? get comments? spider? fast, high risk arachni scan?
smb: enum4linux? null session
ftp: Anonymous? brute?
mssql: brute sa since it can't be locked out? Do I want login bruteforcing?
smtp: smtp-open-relay + smtp-enum-users
snmp: bruteforce the string
'''

def parse_args():
    # Create the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-x", "--nmapxml", help="Nmap XML file to parse")
    parser.add_argument("-l", "--hostlist", help="Host list file")
    return parser.parse_args()

@trollius.coroutine
def main(report):
    procs = []
    msg = '[*]   Testing {0} service at {1}'
    run_msg = '[*]   Running {0}...'
    for host in report.hosts:
        ip = host.address
        if host.is_up():
            if len(host.hostnames) != 0:
                print '[+] Host: {0}  Hostname: {1}'.format(ip, host.hostnames[0])
            else:
                print '[+] Host: {0}'.format(ip)

        # Get services
        for s in host.services:
            port = str(s.port)
            #print 'Service: {0}/{1} {2} {3}'.format(port, s.protocol, s.state, s.service)
            ip_port = '{0}:{1}'.format(ip, port)

            # HTTP
            if 'http' in s.service:
                #print msg.format('HTTP', ip_port)
                cmd = '/usr/bin/nikto -h {0}'.format(ip_port)
                nikto = yield From(trollius.create_subprocess_exec('/usr/bin/nikto', '-h', ip_port, stdout=PIPE, stderr=STDOUT))
                print run_msg.format(cmd)
                # Append the (Process, output_filename) to master list
                procs.append((nikto, 'http_results.txt'))

            # UNTESTED SMTP #
            elif 'smtp' in s.service:
                #print msg.format('SMTP', ip_port)
                cmd = '/usr/bin/nmap -n -pT:{0} --script smtp-open-relay smtp-enum-users'.format(ip_port)
                nmap_smtp = yield From(trollius.create_subprocess_exec('/usr/bin/nmap', '-pT:{0}'.format(str(port)), '-n',
                                '--script', 'smtp-open-relay', 'smtp-enum-users', ip, stdout=PIPE, stderr=STDOUT))
                print run_msg.format(cmd)
                procs.append((nmap_smtp, 'smtp_results.txt'))

            # UNTESTED SMB #
            elif 'smb' in s.service:
                #print msg.format('SMB', ip_port)
                cmd = '/usr/bin/enum4linux -a {0}'.format(ip)
                enum4linux = yield From(trollius.create_subprocess_exec('/usr/bin/enum4linux', '-a', ip))
                print run_msg.format(cmd)
                procs.append((enum4linux, 'smb_results.txt'))

    yield From(write_output(procs))

@trollius.coroutine
def write_output(procs):
    '''
    Write the various programs' outputs to file:
    {service}_results.txt
    '''
    ########################
    # I keep getting nikto "defunct" yet not returning a returncode
    # Maybe have to put the create_subprocess_exec into it's own function?
    # http://stackoverflow.com/questions/24541192/python-asyncio-subprocess-never-finishes
    ###########################
    once_more = False
    print procs
    print [p[0].returncode for p in procs]
    print [p[0].returncode for p in procs].count(None)
    while [p[0].returncode for p in procs].count(None) > 0:
        for proc, filename in procs:
            print proc.returncode
            if proc.returncode != None:
                stdout, _ = yield From(proc.communicate())
                with open(filename, 'a') as f:
                    for line in stdout:
                        if line:
                            f.write(line)
                    # Add two newlines between each proc output
                    f.write('\n\n')

        try:
            time.sleep(2)
        except KeyboardInterrupt:
            embed()

        if procs.count(None) == 0:
            once_more = True

    if once_more == True:
        for proc, filename in procs:
            print proc.returncode
            if proc.returncode != None:
                with open(filename, 'a') as f:
                    stdout = yield From(proc.communicate())
                    for line in stdout:
                        if line:
                            f.write(line)
                    # Add two newlines between each proc output
                    f.write('\n\n')


def nmap_scan(hosts):
    '''
    Do Nmap scan
    '''
    # -sV is included by default in NmapProcess nmap cmd
    # To add more:  options = '-T4 -sU -p-'
    #                 hosts = ['192.168.0.1', '192.168.0.2']
    nmap_proc = NmapProcess(targets=hosts, options='-T4')
    rc = nmap_proc.run()
    xml = nmap_proc.stdout

    #while nmap_proc.is_running():
    #    print "Nmap Scan running: ETC: {0} DONE: {1}%".format(nmap_proc.etc,
    #                                                          nmap_proc.progress)
    #    time.sleep(2)

    #print "rc: {0} output: {1}".format(nmap_proc.rc, nmap_proc.summary)

    try:
        report = NmapParser.parse(nmap_proc.stdout)
    except NmapParserException as e:
        print 'Exception raised while parsing scan: {0}'.format(e.msg)

    return report


if __name__ == "__main__":
    args = parse_args()

    if args.nmapxml:
        report = NmapParser.parse_fromfile(args.nmapxml)
    elif args.hostlist:
        with open(args.hostlist, 'r') as hostlist:
            hosts = hostlist.read().split()
        report = nmap_scan(hosts)
    else:
        print 'Please use the "-f [nmapoutput.xml]" option if you already have an nmap XML file \
or "-h [hostlist.txt]" option to run an nmap scan with a hostlist file.'
        sys.exit()

    loop = trollius.get_event_loop()
    loop.run_until_complete(main(report))
