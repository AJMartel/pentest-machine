#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import sys
import time
import signal
import argparse
import requests
import subprocess
import concurrent.futures as cf
from selenium import webdriver
from subprocess import Popen, STDOUT, PIPE
from multiprocessing import Process, Pool, Manager
from requests_futures.sessions import FuturesSession
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException
requests.packages.urllib3.disable_warnings()
# Debug
#from IPython import embed

def parse_args():
    # Create the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-x", "--nmapxml", help="Nmap XML file to parse")
    parser.add_argument("-l", "--hostlist", help="Host list file")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Number of parallel workers")
    parser.add_argument("--no-brute", help="SKip all bruteforce attacks", action="store_true")
    return parser.parse_args()

def init_worker():
    '''
    Initialize the Pool() with a signal catcher that will ignore
    the signal forcing it up to the func that called Pool()
    '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)

def make_output_dirs():
    '''
    Create output directories
    '''
    if not os.path.exists('output-by-host'):
        os.makedirs('output-by-host')
    if not os.path.exists('output-by-service'):
        os.makedirs('output-by-service')

def get_cmds(hosts, urls):
    '''
    Gather the commands to run
    '''
    hostnames = []
    cmds = []

    for host in report.hosts:
        ip = host.address
        if host.is_up():
            # type(host.hostnames) == list
            if len(host.hostnames) != 0:
                hostname = host.hostnames[0]

            # Each cmd = {service_str:[(cmd_string1, ip, service, bruteforce, slow_running)]}
            cmds += get_cmds_per_host(host, hostname, ip, urls, args)

    return cmds

def get_cmds_per_host(host, hostname, ip, urls, args):
    '''
    For each service type, add commands to run against it
    '''
    cmds = []

    if len(host.services) == 0:
        print '[-] No services detected'

    for s in host.services:
        port = str(s.port)

        # serv_cmds = {service_str:[(cmd_string1, ip, service, bruteforce, slow_running)]}
        serv_cmds = get_cmds_per_service(ip, port, urls)

        if 'open' == s.state:
            for serv in serv_cmds:
                # check if the service cmd is contained anywhere in the service name
                if re.search(serv, s.service):
                    for cmd in serv_cmds[serv]:
                        # Remove unnecessary cmds
                        cmd = filter_cmds(cmd)
                        cmds.append(cmd)

    # Remove bruteforce
    if args.no_brute and len(cmds) > 0:
        cmds = remove_brute(cmds)

    #Sort the commands so the fastest are at the front of the list
    # x[4] is boolean, True for slow running, False for fast running
    sorted_cmds = sorted(cmds, key=lambda x:x[4])
    cmds = sorted_cmds

    return cmds

def filter_cmds(cmd_data):
    '''
    Remove unnecessary cmds
    cmd_data[0] = command string
    '''
    # RPC
    # only do showmount if it's an NFS port
    if '/sbin/showmount' in cmd_data[0]:
        if port not in ['111', '2049']:
            return

    return cmd_data

def remove_brute(cmds):
    '''
    Remove bruteforce cmds from list
    '''
    for c in cmds:
        # c[4] is boolean for whether it's a brute cmd or not
        no_brute_cmds = [c for c in cmds if c[4] == False]

    return no_brute_cmds

def get_cmds_per_service(ip, port, urls):
    '''
    List of cmds to run on a per-service basis
    serv_cmds = {service_str:[(cmd_string, ip, service, bruteforce, slow_running)]}
    '''

    # Any better data structures?
    serv_cmds = {'ftp':[('patator ftp_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
-x ignore:egrep="failed" --max-retries 2 port={1}'.format(ip, port), ip, 'FTP', True, True)],

                 # Eventually add bruteforce against SMTP by first doing smtp_vrfy brute then using those SNs to attack
                 'smtp':[('sudo /usr/bin/nmap -Pn -n -pT{0} --script smtp-enum-users,smtp-open-relay {1}'.format(port, ip), ip, 'SMTP', False, False)],

                 'isakmp':[('sudo /usr/bin/ike-scan -M -A --id=none -Poutput-by-service/{0}-IKE-PSK.txt \
-Poutput-by-host/{0}-IKE-PSK.txt {0}'.format(ip), ip, 'ISAKMP', False, False)],

                 'postgre':[('patator postgresql_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
--max-retries 2'.format(ip), ip, 'Postgres', True, True)],

                 'mysql':[('patator mysql_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
--max-retries 2'.format(ip), ip, 'MYSQL', True, True)],

                 'telnet':[('patator telnet_login host={0} inputs="COMBO00\nCOMBO01" 0=wordlists/short-user-pass.list \
reset:fgrep!="Login incorrect", --max-retries 2'.format(ip), ip, 'Telnet', True, True)],

                 'ssh':[('patator ssh_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
-x ignore:egrep="failed." port={1} --max-retries 2'.format(ip, port), ip, 'SSH', True, True)],

                          # There's got to be a better way to do this
                 'snmp':[('/usr/bin/snmpcheck -t {0}'.format(ip), ip, 'SNMP', False, False),
                         ('/usr/bin/snmpcheck -t {0} -c "private"'.format(ip), ip, 'SNMP', False, False),
                         ('/usr/bin/snmpcheck -t {0} -c "cisco"'.format(ip), 'SNMP', False, False)],

                 'rpc':[('sudo /sbin/showmount -e {0}'.format(ip), ip, 'RPC', False, False)],

                 'smb':[('/usr/bin/enum4linux -a {0}'.format(ip), ip, 'SMB', False, False),
                        ('sudo /usr/bin/nmap -Pn -n -pT{0} --script smb-check-vulns,smb-enum-shares {1}'.format(port, ip), ip, 'SMB', False, False)],

                                                                              # These are the only two rdp scripts
                 'ms-wbt-server':[('sudo /usr/bin/nmap -Pn -n -pT{0} --script rdp-enum-encryption,rdp-vuln-ms12-020 {1}'.format(port, ip), ip, 'RDP', False, False)],

                 'ntp':[('sudo /usr/bin/nmap -Pn -n -pU{0} --script ntp-monlist {1}'.format(port, ip), ip, 'NTP', False, False)],

                 'http|www|ssl':http_cmds(port, ip, urls)}

    return serv_cmds

def http_cmds(ip, port, urls):
    '''
    Form all the commands to run against HTTP services
    and add them to the Queue
    Runs: nikto, whatweb, screenshooter(), dirb
    '''

    cmds = []

    for ip_port in urls:
        # Check if the ip_port matches this single hosts's ip and port
        if ip_port == '{0}:{1}'.format(ip, port):
            for url in urls[ip_port]:

                # HTTP screenshots
                if not os.path.exists('output-by-service/HTTP-screenshots'):
                    os.makedirs('output-by-service/HTTP-screenshots')
                ss = 'screenshooter {0}'.format(url)
                cmds.append((ss, ip, 'HTTP', False, False))

                # Nikto
                nikto = '/usr/bin/nikto -h {0}'.format(url)
                cmds.append((nikto, ip, 'HTTP', False, True))

                # WhatWeb
                whatweb = '/usr/bin/whatweb {0}'.format(url)
                cmds.append((whatweb, ip, 'HTTP', False, False))

                # Directory bruteforcing
                dirb = '/usr/bin/dirb -o output-by-service/dirb-{0}.txt {1} {0}'.format(url, ip_port, 'wordlists/dirs-1800.list')
                cmds.append((dirb, ip, 'HTTP', True, True))

    return cmds
    # Wfuzz's output is all unreadable by this script unfortunately
    #wfuzz = 'wfuzz -z file,wordlists/dirs-files-6000.list --hc 404 -I --follow {0}/FUZZ'.format(url)
    #return ((wfuzz.split(), ip, 'HTTP', False))

    # Runs Arachni with high risk checks for 45 min max
    #    ua = "Mozilla/6.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) \
    #Chrome/37.0.2062.124 Safari/537.36"
    #    path = os.getcwd() + '/output-by-host/arachni-report-{0}-{1}.txt'.format(hostname, port)
    #    arachni = 'sudo arachni --output-only-positives --audit-links --audit-forms --http-user-agent \
    #--checks=sql*,file_inclusion,path_traversal,xpath_injection,os_cmd_injection \
    #--browser-cluster-ignore-images --report-save-path={1} --timeout=0:45:0 "{2}://{3}"'.format(port, path, scheme, hostname)
    #    # Insert the UA which has spaces in it but can't be split up
    #    # when cmd.split() is called by worker()
    #    arachni_split.insert(6, ua)
    #    return ((arachni_split, ip, 'HTTP'))

def get_urls(report):
    '''
    Create, then asynchronously test all the valid URLs based on http/https and ip/hostname
    '''

    # Create all potential URLs from the IP and hostname
    potential_urls = get_potential_urls(report)

    # Start asynchronous requests to the potential URLs
    resps = resps_from_urls(potential_urls)

    # Get the results from the requests to the potential URLs
    urls = get_working_urls(resps)

    return urls

def get_working_urls(resps):
    '''
    Test each potential URL for a valid resp
    '''
    urls = {}

    print '\n[*] Asynchronously gathering valid URLs...'
    for resp in cf.as_completed(resps):
        try:
            if resp.result().status_code in [200, 401]:
                url, ip_port = resps[resp]
                print '[+]   Successful response: {0}'.format(url)
                if ip_port in urls:
                    urls[ip_port] += [url]
                else:
                    urls[ip_port] = [url]
        except Exception as e:
            pass

    print ''
    return urls

def get_potential_urls(report):
    '''
    Print all the hosts and services per host
    Create all potential URL combinations from the nmap IP/hostname
        http://ip
        http://hostname
        https://ip
        https://hostname
    '''
    potential_urls = {}

    for host in report.hosts:
        ip = host.address
        if host.is_up():
            hostname = None
            if len(host.hostnames) != 0:
                hostname = host.hostnames[0]
                print '\n[*] Host: {0}  Hostname: {1}'.format(ip, hostname)
            else:
                print '\n[+] Host: {0}'.format(ip)
            for s in host.services:
                port = str(s.port)
                print '[*]   {0}/{1} {2} {3}'.format(port, s.protocol, s.state, s.service)
                ip_port = '{0}:{1}'.format(ip, port)
                if re.search('http|www|ssl', s.service):
                    # Create the potential URLs
                    host_urls = make_urls(ip, port, hostname)
                    if host_urls:
                        potential_urls[ip_port] = host_urls

    return potential_urls

def resps_from_urls(potential_urls):
    '''
    Gather valid responses from the list of potential urls
    '''
    resps = {}
    session = FuturesSession(max_workers=25)

    for ip_port in potential_urls:
        host_resps = []
        for url in potential_urls[ip_port]:
            resp = session.get(url, timeout=20, verify=False)
            host_resps.append(resp)
            resps[resp] = (url, ip_port)

    return resps

def screenshooter(ip, url):
    '''
    Open a phantomjs browser and take a screenshot
    '''

    output = ''

    try:
        browser = webdriver.PhantomJS(service_args=['--ignore-ssl-errors=true','--ssl-protocol=tlsv1'], executable_path="phantomjs")
    except WebDriverException:
        output += '[-] PhantomJS failed, are you sure its installed and in your $PATH?\n'
        return output

    output += '[*] Taking screenshot of {0}\n'.format(url)
    ss_name = url.split('://')[1].replace(':', '-')
    browser.set_window_size(1024, 768)
    browser.set_page_load_timeout(60)

    try:
        browser.get(url)

        # Selenium makes the page source equal to this when it fails to connect
        if '<html><head></head><body></body></html>' == browser.page_source:
            output += '[-] Failed to fetch the page\n'
            return output

        fname = 'output-by-service/HTTP-screenshots/{0}.png'.format(ss_name)
        browser.save_screenshot(fname)
    except Exception as e:
        output += '[-] Failed: {0}\n'.format(str(e))
        return output

    output += '[+] Saved screenshot {0}.png\n'.format(ss_name)
    browser.quit()

    return output

def make_urls(ip, port, hostname):
    '''
    Create all potential URLs, http://hostname, http://ip, https://hostname, https://ip
    '''
    urls = []

    if port == '443':
        if hostname:
            urls.append('https://{0}:{1}'.format(hostname, port))
        urls.append('https://{0}:{1}'.format(ip, port))
        return urls
    else:
        if hostname:
            urls.append('http://{0}:{1}'.format(hostname, port))
            urls.append('https://{0}:{1}'.format(hostname, port))
        urls.append('http://{0}:{1}'.format(ip, port))
        urls.append('https://{0}:{1}'.format(ip, port))
        return urls

def run_pool(pool, lock, cmds):
    '''
    Kick off the workers in the pool
    '''
    for c in cmds:
        pool.apply_async(worker, args=(lock, c))
    pool.close()
    pool.join()

def worker(lock, cmd_data):
    '''
    Multiprocessing worker that actually runs the commands
    '''

    cmd = cmd_data[0]
    ip = cmd_data[1]
    service = cmd_data[2]
    cmd_list = cmd.split()

    # Run python functions, come in as "<functionname> <args>"
    if 'screenshooter' == cmd_list[0]:
        print '[*] Running command: {0}'.format(cmd)
        url = cmd.split()[1]
        out = screenshooter(ip, url)

    # Run OS cmds
    else:
        print '[*] Running command: {0}'.format(cmd)
        proc = Popen(cmd_list, stdout=PIPE, stderr=STDOUT)
        out = proc.communicate()[0].strip()

    out = adjust_output(cmd, out)
    if out:
        write_output(lock, cmd, ip, service, out)

def write_output(lock, cmd, ip, service, out):
    '''
    Write each cmd's output to a file named by the IP and a file named by the service type
    '''
    with lock:
        msg = '\n[+] OUTPUT: {0}\n{1}'.format(cmd, out)
        print msg

        with open('output-by-host/{0}.txt'.format(ip), 'a+') as f:
            f.write(msg)
        with open('output-by-service/{0}.txt'.format(service), 'a+') as f:
            f.write(msg)

def adjust_output(cmd, out):
    '''
    Remove output from cmds with too much of it and remove errors from some cmds' output
    '''

    skip_output = ['/usr/bin/dirb']

    # Ignore cmds with too much or unprintable output
    for i in skip_output:
        if i == cmd:
            return

    # Skip certain output lines
    adjusted_out = ''
    for l in out.split('\n'):

        # Skip error line in whatweb
        if 'iconv will be deprecated in the future' not in l:
            adjusted_out += l + '\n'

    # Escape colors like whatweb has
    ansi_escape = re.compile(r'\x1b[^m]*m')
    out = ansi_escape.sub('', adjusted_out)

    return out

def nmap_scan(hosts):
    '''
    Do Nmap scan
    '''
    # -sV is included by default in NmapProcess nmap cmd
    # To add more:  options = '-T4 -sU -p-'
    #                 hosts = ['192.168.0.1', '192.168.0.2']
    #nmap_args = '-T4 -sV -sS -pU:161,137,139'# -sS -sU --top-ports'
    nmap_args = '-T4 -sS -sV --max-rtt-timeout 150ms --max-retries 3'
    print '[*] Running: nmap {0} -iL <hostlist>'.format(nmap_args)
    nmap_proc = NmapProcess(targets=hosts, options=nmap_args)
    #rc = nmap_proc.sudo_run()
    rc = nmap_proc.sudo_run_background()
    while nmap_proc.is_running():
        print("[*] Nmap progress: {1}%".format(nmap_proc.etc, nmap_proc.progress))
        time.sleep(2)

    xml = nmap_proc.stdout

    try:
        report = NmapParser.parse(nmap_proc.stdout)
    except NmapParserException as e:
        print 'Exception raised while parsing scan: {0}'.format(e.msg)
        sys.exit()

    return report

def main(report, num_workers):
    '''
    Run through the hosts' available services appending their respective commands
    to a list, then have x number of workers run through those commands
    '''
    args = parse_args()
    # Can't just use multiprocessing.Lock() because you can't share locks between pool-created Processes
    lock = Manager().Lock()
    pool = Pool(num_workers, init_worker)

    # Catching CTRL-C inside pool.async_apply is not straightforward
    # Pool initialized with init_worker which catches CTRL-C then ignores it which
    # forces it to move into the main() func which is then caught here accurately
    def signal_handler(signal, frame):
        print '[-] Killing unfinished processes...'
        if os.path.isfile('ghostdriver.log'):
            os.remove('ghostdriver.log')
        pool.terminate()
        pool.join()
        sys.exit()
    signal.signal(signal.SIGINT, signal_handler)

    # Create output directories
    make_output_dirs()

    # Check web services for valid URLs
    urls = get_urls(report)

    # Run cmds based on the service
    cmds = get_cmds(report.hosts, urls)

    # Kick off the workers in the Pool
    run_pool(pool, lock, cmds)

if __name__ == "__main__":

    if os.geteuid():
        exit('[-] Please run as root')

    args = parse_args()

    if args.nmapxml:
        report = NmapParser.parse_fromfile(args.nmapxml)
    elif args.hostlist:
        with open(args.hostlist, 'r') as hostlist:
            hosts = hostlist.read().split()
        report = nmap_scan(hosts)
    else:
        print 'Please use the "-x [nmapoutput.xml]" option if you already have an nmap XML file \
or "-l [hostlist.txt]" option to run an nmap scan with a hostlist file.'
        sys.exit()

    main(report, args.workers)
