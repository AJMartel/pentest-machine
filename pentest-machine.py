#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import sys
import time
import signal
import argparse
import requests
import subprocess
from multiprocessing import Lock, Process, Queue
from subprocess import Popen, STDOUT, PIPE
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException

# Debug
#from IPython import embed

'''
http: nikto, httpscreenshot? get comments? spider? fast, high risk arachni scan?
smb: enum4linux? null session
ftp: Anonymous? brute?
mssql: brute sa since it can't be locked out? Do I want login bruteforcing?
smtp: smtp-open-relay + smtp-enum-users
snmp: bruteforce the string
'''

def parse_args():
    # Create the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-x", "--nmapxml", help="Nmap XML file to parse")
    parser.add_argument("-l", "--hostlist", help="Host list file")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Number of parallel workers")
    return parser.parse_args()

def main(report, num_workers):
    '''
    Run through the hosts' available services appending their respective commands
    to a list, then have x number of workers run through those commands
    '''
    procs = []
    lock = Lock()
    q = Queue()

    # Catch CTRL-C
    def signal_handler(signal, frame):
        print '[-] Killing processess and closing...'
        for p in procs:
            p.terminate()
    signal.signal(signal.SIGINT, signal_handler)

    # Create output directories
    if not os.path.exists('output-by-host'):
            os.makedirs('output-by-host')
    if not os.path.exists('output-by-service'):
            os.makedirs('output-by-service')

    # Go through the hosts
    hostname = None
    for host in report.hosts:
        ip = host.address
        if host.is_up():
            # type(host.hostnames) == list
            if len(host.hostnames) != 0:
                hostname = host.hostnames[0]
                print '[+] Host: {0}  Hostname: {1}'.format(ip, hostname)
            else:
                print '[+] Host: {0}'.format(ip)

            # Add the various cmds and filenames to the queue
            get_services(host, hostname, ip, q)

    # Go through the queue with x number of workers
    for w in xrange(num_workers):
        p = Process(target=worker, args=(q, lock))
        p.start()
        procs.append(p)
        q.put('STOP')

    for p in procs:
        p.join()

# Lets make this write its output by host and by protocol
# one folder named output-by-host another output-by-protocol
def get_services(host, hostname, ip, q):
    '''
    For each service type, add a command to run against it to the queue
    '''
    for s in host.services:
        port = str(s.port)
        print '[*]   {0}/{1} {2} {3} {4}'.format(port, s.protocol, s.state, s.service, s.servicefp)
        ip_port = '{0}:{1}'.format(ip, port)

        # Telnet
        #   bruteforce
        # SSH
        #   bruteforce
        # DNS
        # FTP
        #   bruteforce
        # NFS
        #   showmount
        # IKE
        #  ike-scan
        # HTTP
        #  arachni
        #  whatweb

        # HTTP
        if 'http' in s.service:
            http_cmds(q, ip_port, hostname, s.service)

        # UNTESTED SMTP #
        elif 'smtp' in s.service:
            smtp_cmds(q, ip, ip_port)

        # UNTESTED SMB #
        elif 'smb' in s.service:
            smb_cmds(q, ip, ip_port)

        # RPC
        elif 'rpc' in s.service:
            nfs_cmds(q, ip, ip_port)

def rpc_cmds(q, ip, ip_port):
    port = ip_port.split(':')[1]
    nmap_nfs = '/usr/bin/nmap -n -pT:{0} -sV --script nfs-showmount {1}'.format(port, ip)
    q.put((nmap_nfs, ip, 'RPC'))

def http_cmds(q, ip_port, hostname, service):
    '''
    Form all the commands to run against HTTP services
    and add them to the Queue
    '''
    # If fail == True, then couldn't make a connection on
    # HTTPS or HTTP
    ssl, fail = test_ssl(hostname, ip_port)
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    nikto = '/usr/bin/nikto -h {0}'.format(ip_port)
    q.put((nikto, ip, 'HTTP'))

    if fail == False:
        whatweb = get_whatweb_cmd(ip_port, hostname, ssl)
        q.put((whatweb, ip, 'HTTP'))

def test_ssl(hostname, ip_port):
    '''
    Test if service is accessible via SSL or not
    '''
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]
    fail = False
    ssl = False

    # HTTP
    if hostname:
        req = requests.get('http://{0}'.format(hostname))
    else:
        req = requests.get('http://{0}'.format(ip))
    if req.status_code != 200:
        fail = True

    # HTTPS
    if fail == True:
        if hostname:
            req = requests.get('https://{0}'.format(hostname))
        else:
            req = requests.get('https://{0}'.format(ip))
        if req.status_code == 200:
            fail = False
            ssl = True

    return ssl, fail

def get_whatweb_cmd(ip_port, hostname, ssl):
    '''
    Make the WhatWeb command
    '''
    port = ip_port.split(':')[1]
    if ssl == True:
        if hostname:
            hostname = 'https://{0}'.format(hostname)
            whatweb = '/usr/bin/whatweb {0}'.format(hostname)
        else:
            ip = 'https://{0}'.format(ip)
            whatweb = '/usr/bin/whatweb {0}'.format(ip)
    else:
        if hostname:
            hostname = 'http://{0}'.format(hostname)
            whatweb = '/usr/bin/whatweb {0}'.format(hostname)
        else:
            ip = 'http://{0}'.format(ip)
            whatweb = '/usr/bin/whatweb {0}'.format(ip)

    return whatweb

def smtp_cmds(q, ip, ip_port):
    port = ip_port.split(':')[1]
    nmap_smtp = '/usr/bin/nmap -n -pT:{0} --script smtp-enum-users,smtp-open-relay {1}'.format(port, ip)
    q.put((nmap_smtp, ip, 'SMTP'))

def smb_cmds(q, ip, ip_port, hostname):
    enum4linux = '/usr/bin/enum4linux -a {0}'.format(ip)
    q.put((enum4linux, ip, 'SMB'))

def worker(q, lock):
    '''
    Multiprocessing worker that actualy runs the commands
    '''
    for cmd, ip, serv in iter(q.get, 'STOP'):
        cmd_list = cmd.split()
        print '[+] Running command: {0}'.format(' '.join(cmd_list))
        proc = Popen(cmd_list, stdout=PIPE, stderr=STDOUT)
        out = proc.communicate()[0].strip()
        print out+'\n'

        # Escape colors like whatweb has
        ansi_escape = re.compile(r'\x1b[^m]*m')
        out = ansi_escape.sub('', out)

        with lock:
            with open('output-by-host/{0}.txt'.format(ip), 'a+') as f:
                f.write('[*] COMMAND: {0}\n{1}{2}'.format(cmd, out, '\n\n'))
            with open('output-by-service/{0}.txt'.format(serv), 'a+') as f:
                f.write('[*] COMMAND: {0}\n{1}{2}'.format(cmd, out, '\n\n'))

def nmap_scan(hosts):
    '''
    Do Nmap scan
    '''
    # -sV is included by default in NmapProcess nmap cmd
    # To add more:  options = '-T4 -sU -p-'
    #                 hosts = ['192.168.0.1', '192.168.0.2']
    print '[+] Running `nmap -oX - -vvv --stats-every 1s -T4 -sV -sT` against hostlist...'
    nmap_proc = NmapProcess(targets=hosts, options='-T4 -sV')
    rc = nmap_proc.run()
    xml = nmap_proc.stdout

    try:
        report = NmapParser.parse(nmap_proc.stdout)
    except NmapParserException as e:
        print 'Exception raised while parsing scan: {0}'.format(e.msg)
        sys.exit()

    return report


if __name__ == "__main__":
    args = parse_args()

    if args.nmapxml:
        report = NmapParser.parse_fromfile(args.nmapxml)
    elif args.hostlist:
        with open(args.hostlist, 'r') as hostlist:
            hosts = hostlist.read().split()
        report = nmap_scan(hosts)
    else:
        print 'Please use the "-x [nmapoutput.xml]" option if you already have an nmap XML file \
or "-l [hostlist.txt]" option to run an nmap scan with a hostlist file.'
        sys.exit()

    main(report, args.workers)
