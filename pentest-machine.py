#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import sys
import time
import signal
import argparse
import requests
import subprocess
from libnmap.process import NmapProcess
from subprocess import Popen, STDOUT, PIPE
from multiprocessing import Lock, Process, Queue
from libnmap.parser import NmapParser, NmapParserException

# Debug
#from IPython import embed
# Requires:
#  patator
#    ssh_brute in patator needs paramiko

def parse_args():
    # Create the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-x", "--nmapxml", help="Nmap XML file to parse")
    parser.add_argument("-l", "--hostlist", help="Host list file")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Number of parallel workers")
    return parser.parse_args()

def main(report, num_workers):
    '''
    Run through the hosts' available services appending their respective commands
    to a list, then have x number of workers run through those commands
    '''
    procs = []
    lock = Lock()
    q = Queue()

    # Catch CTRL-C
    def signal_handler(signal, frame):
        # Stop further processes from spawning
        q.put('STOP')
        print '[-] Killing process'
        for p in procs:
            p.terminate()
        q.close()
    signal.signal(signal.SIGINT, signal_handler)

    # Create output directories
    if not os.path.exists('output-by-host'):
        os.makedirs('output-by-host')
    if not os.path.exists('output-by-service'):
        os.makedirs('output-by-service')

    # Go through the hosts
    hostname = None
    for host in report.hosts:
        ip = host.address
        if host.is_up():
            # type(host.hostnames) == list
            if len(host.hostnames) != 0:
                hostname = host.hostnames[0]
                print '\n[*] Host: {0}  Hostname: {1}'.format(ip, hostname)
            else:
                print '\n[+] Host: {0}'.format(ip)

            # Add the various cmds and filenames to the queue
            do_service_cmds(host, hostname, ip, q)

    # Go through the queue with x number of workers
    for w in xrange(num_workers):
        p = Process(target=worker, args=(q, lock))
        p.start()
        procs.append(p)
        q.put('STOP')

    for p in procs:
        p.join()

def do_service_cmds(host, hostname, ip, q):
    '''
    For each service type, add a command to run against it to the queue

      To do:
      DNS
      IKE
       ike-scan
      HTTP
       wfuzz dirbusting
      MSSQL
        brute user sa since it can't be locked out
        blank login
      MySQL
        blank login
      Postgresql
        brute/blank login
      DHCP
        ?
      LDAP
        brute
    '''
    if len(host.services) == 0:
        print '[-] No services detected'

    for s in host.services:
        #if 'open' in s.state or 'filtered' in s.state:
        port = str(s.port)
        print '[*]   {0}/{1} {2} {3} {4}'.format(port, s.protocol, s.state, s.service, s.servicefp)

        proto_to_func = {'http|www':http_cmds,
                         'smtp':smtp_cmds,
                         'smb':smb_cmds,
                         'rpc':rpc_cmds,
                         'snmp':snmp_cmds,
                         'ftp':ftp_cmds,
                         'ssh':ssh_cmds,
                         'telnet':telnet_cmds}

        for proto in proto_to_func:
            if re.search(proto, s.service):
                # HTTP testing requires a couple extra vars
                if proto == 'http|www':
                    proto_to_func[proto](q, ip, port, hostname, s.service)
                # All the rest of the protocol testing
                else:
                    proto_to_func[proto](q, ip, port)

def telnet_cmds(q, ip, port):
    '''
    Runs: patator telnet_login
    '''
    # Brute force (never more than 2 tries per username to avoid lockout
    telnet = 'patator telnet_login host={0} inputs="COMBO00\nCOMBO01" 0=short-user-pass.list \
--max-retries -2'.format(ip)
    telnet_split = telnet.split()
    q.put((telnet_split, ip, 'Telnet'))

def ssh_cmds(q, ip, port):
    '''
    Runs: patator ssh_login
    '''
    # Brute force (never more than 2 tries per username to avoid lockout
    # -x free=user:code0 means stop testing the user after successful login
    ssh_login = 'patator ssh_login host={0} user=COMBO00 password=COMBO01 0=long-user-pass.list \
-x ignore:egrep="failed." -x free=user:code=0 port={1} --max-retries -2'.format(ip, port)
    ssh_login_split = ssh_login.split()
    q.put((ssh_login_split, ip, 'SSH'))

def ftp_cmds(q, ip, port):
    '''
    Runs: patator ftp_login, anon login
    '''
    # Brute force (never more than 2 tries per username to avoid lockout except root and admin)
    ftp_login = 'patator ftp_login host={0} user=COMBO00 password=COMBO01 0=long-user-pass.list \
-x ignore:egrep="failed" -x free=user:code=0 port={1} --max-retries -2'.format(ip, port)
    ftp_login_split = ftp_login.split()
    q.put((ftp_login_split, ip, 'FTP'))

def snmp_cmds(q, ip, port):
    '''
    Runs: snmpcheck with 'public' and 'private' strings
    '''
    snmpcheck = '/usr/bin/snmpcheck -t {0}'.format(ip)
    snmpcheck_split = snmpcheck.split()
    q.put((snmpcheck_split, ip, 'SNMP'))

    snmpcheck1 = '/usr/bin/snmpcheck -t {0} -c "private"'.format(ip)
    snmpcheck1_split = snmp_check1.split()
    q.put((snmpcheck1_split, ip, 'SNMP'))

def rpc_cmds(q, ip, port):
    '''
    Runs: showmount
    '''
    showmount = 'sudo /sbin/showmount -e {0}'.format(ip)
    showmount_split = showmount.split()
    q.put((showmount_split, ip, 'RPC'))
    #nmap_nfs = '/usr/bin/nmap -n -Pn -pT:{0} -sV --script nfs-showmount {1}'.format(port, ip)
    #q.put((nmap_nfs, ip, 'RPC'))

def http_cmds(q, ip, port, hostname, service):
    '''
    Form all the commands to run against HTTP services
    and add them to the Queue
    Runs: nikto, whatweb
    '''

    # If fail == True, then couldn't make a connection on
    # HTTPS or HTTP
    print '1'
    proto, fail = test_ssl(hostname, ip, port)
    print '2'
    nikto = '/usr/bin/nikto -h {0}:{1}'.format(ip, port)
    nikto_split = nikto.split()
    q.put((nikto_split, ip, 'HTTP'))

    # request to ip or domain failed
    if fail == False:
        whatweb = get_whatweb_cmd(ip, hostname, proto)
        whatweb_split = whatweb.split()
        q.put((whatweb_split, ip, 'HTTP'))

        # Runs Arachni with high risk checks for 45 min max
        ua = "Mozilla/6.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) \
Chrome/37.0.2062.124 Safari/537.36"
        if hostname:
            path = os.getcwd() + '/output-by-host/arachni-report-{0}-{1}.txt'.format(hostname, port)
            arachni = 'sudo arachni --output-only-positives --audit-links --audit-forms --http-user-agent \
--checks=sql*,file_inclusion,path_traversal,xpath_injection,os_cmd_injection \
--browser-cluster-ignore-images --report-save-path={1} --timeout=0:45:0 "{2}://{3}"'.format(port, path, proto, hostname)
        else:
            path = os.getcwd() + '/output-by-host/arachni-report-{0}-{1}.txt'.format(ip, port)
            arachni = 'sudo arachni --output-only-positives --audit-links --audit-forms --http-user-agent \
--checks=sql*,file_inclusion,path_traversal,xpath_injection,os_cmd_injection \
--browser-cluster-ignore-images --report-save-path={1} --timeout=0:45:0 "{2}://{3}"'.format(port, path, proto, ip)
        arachni_split = arachni.split()
        arachni_split.insert(6, ua)
        q.put((arachni_split, ip, 'HTTP'))

def test_ssl(hostname, ip, port):
    '''
    Test if service is accessible via SSL or not
    '''
    fail = False
    proto = 'http'
    req = None

    # HTTP
    if hostname:
        try:
            req = requests.get('http://{0}'.format(hostname), timeout=20)
        except requests.exceptions.ConnectionError:
            req = None

    # If http://hostname fails
    if req == None:
        try:
            req = requests.get('http://{0}'.format(ip), timeout=20)
        except requests.exceptions.ConnectionError:
            fail = True
            return proto, fail

    if req.status_code not in [200, 401]:
        fail = True

    # HTTPS
    if fail == True:
        if hostname:
            req = requests.get('https://{0}'.format(hostname), timeout=20)
        else:
            req = requests.get('https://{0}'.format(ip), timeout=20)
        if req.status_code == 200:
            fail = False
            proto = 'https'

    return proto, fail

def get_whatweb_cmd(ip, hostname, proto):
    '''
    Make the WhatWeb command
    '''
    if hostname:
        hostname = '{0}://{1}'.format(proto, hostname)
        whatweb = '/usr/bin/whatweb {0}'.format(hostname)
    else:
        ip = '{0}://{0}'.format(proto, ip)
        whatweb = '/usr/bin/whatweb {0}'.format(ip)

    return whatweb

def smtp_cmds(q, ip, port):
    '''
    Runs: Nmap NSE smtp-enum-users,smtp-open-relay
    '''
    nmap_smtp = '/usr/bin/nmap -Pn -n -p {0} --script smtp-enum-users,smtp-open-relay {1}'.format(port, ip)
    nmap_smtp_split = nmap_smtp.split()
    q.put((nmap_smtp.split(), ip, 'SMTP'))

def smb_cmds(q, ip, port):
    '''
    Runs: enum4linux -a
          nmap NSE smb-check-vulns, smb-enum-shares
    '''
    enum4linux = '/usr/bin/enum4linux -a {0}'.format(ip)
    enum4linux_split = enum4linux.split()
    q.put((enum4linux_split, ip, 'SMB'))

    nmap_smb = '/usr/bin/nmap -Pn -n -p {0} --script smb-check-vulns,smb-enum-shares {1}'.format(port, ip)
    nmap_smb_split = nmap_smb.split()
    q.put((nmap_smb_split, ip, 'SMB'))

def worker(q, lock):
    '''
    Multiprocessing worker that actually runs the commands
    '''
    no_output = ['arachni']

    for cmd_list, ip, serv in iter(q.get, 'STOP'):
        cmd = ' '.join(cmd_list)
        print '[+] Running command: {0}'.format(cmd)

        proc = Popen(cmd_list, stdout=PIPE, stderr=STDOUT)
        out = proc.communicate()[0].strip()

        # Ignore cmds with too much output
        for i in no_output:
            if i in cmd:
                return

        # Escape colors like whatweb has
        ansi_escape = re.compile(r'\x1b[^m]*m')
        out = ansi_escape.sub('', out)

        msg = '[*] OUTPUT: {0}\n{1}\n\n'.format(cmd, out)
        print msg

        with lock:
            with open('output-by-host/{0}.txt'.format(ip), 'a+') as f:
                f.write(msg)
            with open('output-by-service/{0}.txt'.format(serv), 'a+') as f:
                f.write(msg)

def nmap_scan(hosts):
    '''
    Do Nmap scan
    '''
    # -sV is included by default in NmapProcess nmap cmd
    # To add more:  options = '-T4 -sU -p-'
    #                 hosts = ['192.168.0.1', '192.168.0.2']
    #nmap_args = '-T4 -sV -sS -pU:161,137,139'# -sS -sU --top-ports'
    nmap_args = '-T4 -sS -sV --max-rtt-timeout 150ms --max-retries 3'
    print '[+] Running: nmap {0} -iL <hostlist>'.format(nmap_args)
    nmap_proc = NmapProcess(targets=hosts, options=nmap_args)
    #rc = nmap_proc.sudo_run()
    rc = nmap_proc.sudo_run_background()
    while nmap_proc.is_running():
        print("[*] Nmap progress: {1}%".format(nmap_proc.etc,
                                                              nmap_proc.progress))
        time.sleep(2)

    xml = nmap_proc.stdout

    try:
        report = NmapParser.parse(nmap_proc.stdout)
    except NmapParserException as e:
        print 'Exception raised while parsing scan: {0}'.format(e.msg)
        sys.exit()

    return report


if __name__ == "__main__":

    if os.geteuid():
        exit('[-] Please run as root')

    args = parse_args()

    if args.nmapxml:
        report = NmapParser.parse_fromfile(args.nmapxml)
    elif args.hostlist:
        with open(args.hostlist, 'r') as hostlist:
            hosts = hostlist.read().split()
        report = nmap_scan(hosts)
    else:
        print 'Please use the "-x [nmapoutput.xml]" option if you already have an nmap XML file \
or "-l [hostlist.txt]" option to run an nmap scan with a hostlist file.'
        sys.exit()

    main(report, args.workers)
